#!/usr/bin/env python3

# TODO: Bake version info into build artifacts.
# TODO: Make more verbose.

import lib.base
from lib.usage import usage
import lib.compressors.css
import getopt
import json
import os
import re
import subprocess
import sys

builds = {}
silent = False
verbose = False
reTaskRef = re.compile(r'utley -*(\w+)')

def main(argv):
    global silent
    global verbose

    configFile = 'utley.json'
    dumpTarget = None
    task = None

    # TODO: Can this be cleaned up?
    # \A = Matches only at the start of the string.
    shortOpts = [arg for arg in argv if re.search('\A-{1}\w', arg)]
    # Match `--clean` or `js`
    allTargetAndTaskOpts = [arg for arg in argv if re.search('\A-{2}\w|\A\w+', arg)]

    try:
        opts, args = getopt.getopt(shortOpts, 'c:hl:st:v')
    except getopt.GetoptError:
        print('[ERROR] Unrecognized flag!')
        usage()
        sys.exit(1)

    for opt, arg in opts:
        if opt == '-h':
            usage()
            sys.exit(0)
        elif opt == '-c':
            configFile = arg
        elif opt == '-l':
            dumpTarget = arg
        elif opt == '-s':
            silent = True
        elif opt == '--task':
            task = arg
        elif opt == '-v':
            verbose = True

    json = lib.base.getJson(configFile)
    # Run all targets, `utley`
#    if not len(targetOpts) and not len(taskOpts):
    if not len(allTargetAndTaskOpts):
        # Assumes `utley.json` config file.
        for target in json:
            if target == 'tasks':
                continue

            buildTarget(target, json)
    elif len(allTargetAndTaskOpts):
        # This provides a shortcut for calling top-level targets (js, css, etc.) or shell commands
        # defined in the `tasks` block.
        buildTargetOrTask(allTargetAndTaskOpts, json)
    else:
        print('[ERROR] No ' + target + ' target found, aborting.')
        sys.exit(1)

def buildTarget(target, json):
    if not silent:
        print('[TARGET] ' + target)

    # Allows for building a top-level target by name, i.e. `js@foo`.
    if '@' in target:
        # Redefine `target` since as it needs to be either js, json or css.
        [target, name] = target.split('@')
        ls = [item for item in getTarget(target, json) if item.get('name') == name]
    else:
        ls = getTarget(target, json)

    doTarget(json, target, ls)

def buildTargetOrTask(allTargetAndTaskOpts, json):
    for arg in allTargetAndTaskOpts:
        if '--' in arg:
            # Chop off '--' prefix.
            task = arg[2:]

            if not silent:
                print('[TASK] ' + task)

            doTask(task, json)
        else:
            buildTarget(arg, json)

def doConcat(target, targetName):
    global builds

    for targetCfg in target:
        if not silent:
            print('\t[ARTIFACT] Building ' + targetCfg.get('output'))

        buff = []

        src = targetCfg.get('src')
        dest = targetCfg.get('output')
        dependencies = targetCfg.get('dependencies', [])
        exclude = targetCfg.get('exclude', [])
        name = targetCfg.get('name', '')

        ls = lib.base.sift_list(
            lib.base.make_list(src),
            targetName,
            lib.base.make_list(exclude),
            lib.base.make_list(dependencies)
        )

        buff = preprocess(targetCfg, targetName, ls, dest)

        if not buff:
            buff = []

            for script in ls:
                # If script is a named target then retrieve it from the global `builds` dict.
                # Note that it assumes the named target was already built!
                # TODO
                if script[0] == '@':
                    buff.append(''.join(builds.get(script[1:])))
                else:
                    script = open(script, 'r')

                    for line in script:
                        buff.append(line)

                    script.close()

            with open(dest, mode='w', encoding='utf8') as fp:
                fp.write(''.join(buff))

        if not silent:
            print('\t\t[INF] Concatenated\n')

        if name:
            builds.update({
                name: buff
            })

def doTarget(json, target, ls):
    # If operating on one of the known extensions then pass it directly on.
    if target in lib.base.compressors.keys():
        doConcat(ls, target)
    else:
        if ls == None:
            print('[ERROR] Unrecognized target `' + target + '`')
            sys.exit(1)
        else:
            for subtarget in ls:
                buildTarget(subtarget, ls)

def doTask(key, json):
    tasks = json.get('tasks')
    task = tasks.get(key)

    if task:
        if verbose:
            print('[DEBUG] Processing -> ' + task)

        # If the task references another task, don't create a subprocess.
        if 'utley' in task:
            buildTargetOrTask([arg for arg in task.split(' ')[1:] if re.search('\A[-{2}\w|\w+]', arg)], json)
        else:
            # Instead of handling a non-zero exit code here and throwing, each shell command will have
            # to clean up after itself.
            subprocess.call(task, shell=True)
    elif not task and not silent:
        print('[ERROR] Unrecognized task `' + key + '`')
        sys.exit(1)

def getNestedTarget(keys, ls):
    for key in keys:
        ls = ls.get(key)

    return ls

def getTarget(target, json):
    # Check to see if target is a subtarget (i.e., 'quizzes.chord_builder').
    # It will only be dot-separated if explicitly passed as a build target.
    return getNestedTarget(target.split('.'), json) if '.' in target else json.get(target)

def preprocess(cfg, target, ls, dest):
    buff = None

    utleyCfg = lib.base.getJson(lib.base.getConfigFileLocation())
    lang = utleyCfg.get(target)

    if lang:
        # TODO: Cleanup?
        # TODO: DRY
        transpiler = cfg.get('transpile') if cfg.get('transpile') != None else lang.get('transpile')
        compressor = cfg.get('compress') if cfg.get('compress') != None else lang.get('compress')

        if transpiler and compressor:
            ls.insert(0, transpiler)

            p1 = subprocess.Popen(ls, stdout=subprocess.PIPE)
            p2 = subprocess.Popen([compressor], stdin=p1.stdout, stdout=subprocess.PIPE)
            p1.stdout.close()
            buff = p2.communicate()[0]
            p2.stdout.close()

            with open(dest, mode='w', encoding='utf8') as fp:
                fp.write(''.join(buff.decode('utf8')))

        elif transpiler:
            ls.insert(0, transpiler)

            p = subprocess.Popen(ls, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
            buff = p.communicate()[0]
            p.stdout.close()

            with open(dest, mode='w', encoding='utf8') as fp:
                fp.write(''.join(buff.decode('utf8')))

        elif compressor:
            if target == 'css' or target == 'json':
                buff = lib.compressors.css.compress(ls)
            elif target == 'js':
                ls.insert(0, 'cat')

                p1 = subprocess.Popen(ls, stdout=subprocess.PIPE)
                p2 = subprocess.Popen([compressor], stdin=p1.stdout, stdout=subprocess.PIPE)
                p1.stdout.close()
                buff = p2.communicate()[0]
                p2.stdout.close()

            with open(dest, mode='w', encoding='utf8') as fp:
                fp.write(''.join(buff.decode('utf8')))

        else:
            print('\t\t[INF] No transpilation or compression')

        if not silent:
            if transpiler:
                print('\t\t[INF] Transpiled')

            if compressor:
                print('\t\t[INF] Compressed')
    elif not silent:
        print('\t\t[INF] Nothing configured for ' + target)

    return buff

if __name__ == '__main__':
    main(sys.argv[1:])

